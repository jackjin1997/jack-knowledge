# DDD 战略设计参考

## 目录

1. [子域类型](#子域类型)
2. [限界上下文](#限界上下文)
3. [上下文映射](#上下文映射)
4. [通用语言](#通用语言)

---

## 子域类型

### 核心域（Core Domain）

核心域是企业的核心竞争力所在，是需要投入最多资源和最优秀人才的领域。

**特征：**
- 直接产生业务价值
- 竞争对手难以复制
- 需要持续投资和迭代

**示例：**
- 电商平台的推荐算法
- 金融公司的风控模型
- 物流公司的路径优化

### 支撑域（Supporting Subdomain）

支撑域为核心域提供必要支持，虽然重要但不是核心竞争力。

**特征：**
- 支持核心业务运作
- 可能有一定定制需求
- 可以外包但需要监控质量

**示例：**
- 用户管理
- 权限系统
- 工单系统

### 通用域（Generic Subdomain）

通用域是可以直接购买或使用通用解决方案的领域。

**特征：**
- 没有差异化优势
- 标准解决方案即可满足
- 优先购买而非自建

**示例：**
- 邮件发送服务
- 短信网关
- 支付接口

---

## 限界上下文

### 定义原则

1. **语义边界** - 同一个词在不同上下文可能有不同含义
2. **团队边界** - 一个团队负责一个或少数几个上下文
3. **技术边界** - 上下文可以独立部署和演进
4. **生命周期边界** - 上下文内的对象有相似的生命周期

### 识别方法

```
步骤1：列出所有业务概念
步骤2：识别概念的不同含义
步骤3：按语义相关性分组
步骤4：验证团队和技术可行性
```

### 示例：电商系统限界上下文

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   商品目录   │    │   订单管理   │    │   库存管理   │
│  上下文     │    │   上下文    │     │   上下文    │
├─────────────┤    ├─────────────┤    ├─────────────┤
│ Product     │    │ Order       │    │ Inventory   │
│ Category    │    │ OrderItem   │    │ StockItem   │
│ Brand       │    │ Payment     │    │ Warehouse   │
└─────────────┘    └─────────────┘    └─────────────┘

┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   用户中心   │    │   支付中心   │    │   物流配送   │
│  上下文     │    │   上下文    │     │   上下文    │
├─────────────┤    ├─────────────┤    ├─────────────┤
│ User        │    │ Transaction │    │ Shipment    │
│ Address     │    │ Account     │    │ Delivery    │
│ Profile     │    │ Wallet      │    │ Route       │
└─────────────┘    └─────────────┘    └─────────────┘
```

---

## 上下文映射

### 映射模式详解

#### 1. 共享内核（Shared Kernel）

两个上下文共享一部分模型代码。

```
  上下文A          共享内核          上下文B
┌─────────┐    ┌─────────────┐    ┌─────────┐
│         │    │   Money     │    │         │
│   ───────────►│  Address   │◄───────────  │
│         │    │   DateTime  │    │         │
└─────────┘    └─────────────┘    └─────────┘
```

**适用场景：**
- 紧密协作的团队
- 共享的基础类型
- 需要严格协调变更

**风险：**
- 紧耦合
- 变更需要多方协调

#### 2. 客户-供应商（Customer-Supplier）

上游供应商为下游客户提供服务。

```
供应商（上游）                  客户（下游）
┌─────────────┐              ┌─────────────┐
│  订单服务    │─────────────►│  发票服务    │
│             │   API/事件   │             │
└─────────────┘              └─────────────┘
```

**协作方式：**
- 下游可以影响上游的优先级
- 上游需要考虑下游需求
- 版本管理和向后兼容

#### 3. 遵从者（Conformist）

下游完全遵从上游的模型，无话语权。

```
上游（强势方）                 下游（遵从方）
┌─────────────┐              ┌─────────────┐
│  第三方支付  │─────────────►│  我方订单    │
│   系统      │   强制API    │   系统       │
└─────────────┘              └─────────────┘
```

**适用场景：**
- 集成第三方服务
- 上游没有定制意愿
- 下游无法影响上游

#### 4. 防腐层（Anti-Corruption Layer）

在下游构建隔离层，转换上游模型。

```
上游系统                   防腐层                    下游系统
┌─────────────┐    ┌─────────────────┐    ┌─────────────┐
│  遗留系统    │───►│   适配器        │───►│  新系统      │
│  (旧模型)   │    │  翻译器/门面    │    │  (新模型)   │
└─────────────┘    └─────────────────┘    └─────────────┘
```

**实现方式：**

```python
# 防腐层示例
class LegacyOrderAdapter:
    """将遗留订单系统的模型转换为新领域模型"""
    
    def __init__(self, legacy_client: LegacyOrderClient):
        self.legacy_client = legacy_client
    
    def get_order(self, order_id: str) -> Order:
        legacy_order = self.legacy_client.fetch_order(order_id)
        return self._translate(legacy_order)
    
    def _translate(self, legacy: LegacyOrder) -> Order:
        return Order(
            id=OrderId(legacy.order_no),
            customer_id=CustomerId(legacy.cust_id),
            items=[self._translate_item(i) for i in legacy.lines],
            status=self._map_status(legacy.state)
        )
```

#### 5. 开放主机服务（Open Host Service）

提供标准化的服务接口供多方使用。

```
                    ┌─────────────┐
                    │   消费者A   │
                    └──────▲──────┘
                           │
┌─────────────┐    ┌───────┴───────┐    ┌─────────────┐
│  开放主机    │───►│   标准API     │◄───│   消费者B   │
│  服务       │    │  (REST/gRPC)  │    │             │
└─────────────┘    └───────┬───────┘    └─────────────┘
                           │
                    ┌──────▼──────┐
                    │   消费者C   │
                    └─────────────┘
```

#### 6. 发布语言（Published Language）

定义共享的数据交换格式。

```json
// 发布语言示例：订单事件
{
  "eventType": "OrderCreated",
  "eventVersion": "1.0",
  "timestamp": "2024-01-01T10:00:00Z",
  "payload": {
    "orderId": "ORD-12345",
    "customerId": "CUST-789",
    "items": [
      {
        "productId": "PROD-001",
        "quantity": 2,
        "unitPrice": {
          "amount": 99.99,
          "currency": "CNY"
        }
      }
    ]
  }
}
```

---

## 通用语言

### 建立通用语言的步骤

1. **收集业务术语** - 与领域专家对话，收集专业词汇
2. **消除歧义** - 明确每个术语的精确定义
3. **建立词汇表** - 形成文档化的术语表
4. **代码即文档** - 代码中使用通用语言命名

### 通用语言示例

| 业务术语 | 精确定义 | 代码命名 |
|---------|---------|---------|
| 订单 | 客户一次购买行为的记录 | `Order` |
| 下单 | 创建新订单的行为 | `placeOrder()` |
| 订单项 | 订单中的单个商品记录 | `OrderItem` |
| 支付 | 客户完成付款的行为 | `Payment` |
| 发货 | 仓库将商品交付物流 | `Shipment` |
| 签收 | 客户确认收到商品 | `confirmReceipt()` |

### 通用语言反模式

**错误示例：**
```python
# 技术术语而非业务术语
class DataManager:
    def insert_record(self, data): pass
    def update_entity(self, entity): pass
```

**正确示例：**
```python
# 使用通用语言
class OrderRepository:
    def save_order(self, order: Order): pass
    def find_by_customer(self, customer_id: CustomerId): pass
```
